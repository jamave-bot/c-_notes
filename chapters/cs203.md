# CS 203

***Date**: 1/25/24*

When we code there are 3 places our code is stored:

**Code**

The instructions of the program

**Stack**

Where our function calls/temporary data is stored

**Heap**

The heap is where data is stored permanently. It's up to us to delete this data. 


```
in linux, some useful commands to navigate terminal:

pwd: (print working directory) shows current location 
ls: (list) shows what's in current folder
cd: (change directory) changes directory to a directory inside current location
    without argument, goes to home directory
    .. :goes back to parent directory

```

## Steps to coding in C++

Editing -> Preprocessing -> Compilation (Object code) -> Linking process -> Loading -> Execution


**Preprocessing** -> e.g. #includes which tells us what libraries we're going to be using

We will be combining preprocessing and compilation to 1 step and we'll be combining the last 3 to 1 step


## sample c++

```cpp
int main() {
    int x; // declaration
    int y,z; // declares y and z
    int t=42; // declaration and initialization
    string msg="Hello"; // declaration and initialization
    x=10;
    y=x+t; // 52
    z=y; // 52
    y=y*2; //104
    msg = msg + "; y="; // "Hello; y="
    cout << msg << y << "; z=" << z << endl; 
    return 0;
}
```


1 byte = 8 bits
int uses 4 bytes, so 32 bits

in 32 bits, the first is the **signed bit**, 

if it's **0(unsigned)**, the number will be **positive**, 

if **1(signed)**, the number will be **negative** 

since we only have 31 bits, the largest int we can hold is 2<sup>31</sup>

any type declaration/initialization that has **unsigned** will be positive no matter what. 


<hr>

***Date**: 1-29-24*

## Going over comparison operators

- different data types will not give a true boolean value despite having the same value 
    - e.g. 
    
    ```cpp
    float x = 0.1; 
    double y = 0.1; 
    cout << x == y  //would return false (0);
    ```

in order to see 'true' or 'false' we have to add the 'bool alpha' statement to the cout
    
e.g.
```cpp
cout << bool alpha << (a == b); // would show 'true' or 'false'
```

**Negation** has precedence over conjuntion and disjunction

- anything other than 0 in C++ is evaluated as true

**Conjunction** has precedence over disjunction


**&& and || are short circuit (aka lazy) operators.**

- When evaluating a&&b, if a is false, b is not evaluated
- when evaluating a||b, if a is true, b is not evaluated 

## The string type

- String is not primitice and requires the inclusino of the string library 
 ```cpp
 #include <string>
 ```

 Some escaped sequences include 
 
- \n newline
- \r returns the cursor to the front 


**cin** only records one line, to read the entire input we have to use **getline**

e.g. 
```cpp
#include <iostream>
#include <string>
using namespace std;

int main (){
    string s;

    cout << "Enter a string: ";
    // cin >> s; this would only record 1 word
    getline(cin, s);

    cout << s << endl; // would return the entire line inputted

    return 0;
}
```

- the 1st argument in getline is the istream object from which characters are extracted 
- the 2nd argument is where the input is stored

## Flow control

- if/else
- switch

e.g.
```cpp
switch (value to be checked){
    case value:
        instructions
        break;
    case value:
        instructions
        break;
    case value:
        instructions
        break;
    default: 
        instructions
        break;
}
```

### for loops

syntax: 
```cpp
for (initialization; test; action){
    loop content;
}
```
<br>
e.g. decrementing for loop

```cpp
int main(){
    for(int i = 100; i >= 1; i--){
        cout << i << endl;
    }
    return 0;
}
```

### while loops

syntax:
```cpp
while(condition){
    loop content;
}
```

e.g. while loop with input
```cpp
string user_input;
cout << "Hi, input line: ";
while (getline(cin, user_input)){ 
    // this will continue as long as user doesn't input the 'end input' command
    cout << "Tell me more...";
} // to exit this in linux, user can enter ctrl+D

cout << "thanks for ending it all!";
```

## Functions

syntax: 
```cpp
return_type function_name (type_of_arg1 name_of_arg1 type_of_arg2 name_of_arg2...){
    //code
}
```

e.g.
```cpp
float volumeCylinder (float radius, float height){
    return radius * radius * 3.14 * height;
}

int main(void){
    cout << volumeCylinder(4,6) << endl;
}
```

## the void type

- A type that isn't one
- the type of nothingness
- Sometimes also used to mean 'unknown'

<hr>

***Date:** 1/31/24*

## Arrays 

- An array is a contiguous group of memory locations that all have the same type.
- To refer to a particular location or element in the array, specify the name of the array and the position number of the particular element.
- The position number is more formally called a subscript or index (this number specifies the number of elements from the beginning of the array).
- The first element in every array has subscript 0 (zero) and is sometimes called the zeroth element.


```cpp
#include <iostream>
#include <array>

using namespace std;

int main(){
    array<int, 10> myintarray; // initialize an array of 10 int elements called myintarray

    // To display the elements in the array
    for (int i = 0; i < myintarray.size(); i++){ //size() function returns the initalized size of the array
        myintarray[i] = i+1; //stores the value of i in the corresponding index - 1
    }

    for (int element: myintarray){ // for every integer element in myintarray
        cout << element << " ";
    }

    cout << endl;

    return 0;
}
```

<hr>

***Date**: 2-1-24*

## Classes 

```cpp
// Account.h

#ifndef ACCOUNT_H //if this is not defined, we define it here, this prevents error of multiple includes of this file in other files
#define ACCOUNT_H 

#include <string>
#include <iostream>

class Account{
public:
    Account(){}

    explicit Account(std::string accountName):name(accountName){} //if only 1 argument we can put the word 'explicit' before the function name

    Account(std::string accountName, int initialBalance) 
        :name(accountName){

        if (initialBalance > 0){
            balance = initialBalance;
        }
    }

    void deposit(int depositAmount){
        if (depositAmount > 0){
            balance = balance + depositAmount;
        }
    }

    int getBalance() const{
        return balance;
    }

    void setName(std::string accountName){
        name = accountName;
    }

    std::string getName() const{ // const keyword after to ensure no data is being changed
        return name;
    }

    void withdraw(int withdrawAmount){
        if (withdrawAmount <= balance){
            balance = balance - withdrawAmount;
        } else{
            std::cout << "Withdrawal amount exceeded account balance";
        }
    }

private:
    std::string name; // default constructor called here 
    int balance{0};
};

#endif //ends the define
```

<hr>

***Date:** 02/05/24*

## Pointers

- Pointers also enable pass-by-reference and can be used to create and manipulate pointer-based dynamic data structures.

<br>

- A pointer contains the memory address of a variable that, in turn, contains a specific value.
- In this sense, a variable name directly references a value, and a pointer indirectly references a value.
- Referencing a value through a pointer is called indirection.
- Diagrams typically represent a pointer as an arrow from the variable that contains an address to the variable located at that address in memory

### Declaring Pointers

The declaration 
```cpp
int* countPtr, count;
int *countPtr;
```

declares the variable countPtr to be of type int* (i.e., a pointer to an int value) and is read (right to left), “countPtr is a pointer to int.”
Variable count in the preceding declaration is declared to be an int, not a pointer to an int.

The * in the declaration applies only to countPtr.
Each variable being declared as a pointer must be preceded by an asterisk (*).
When * appears in a declaration, it is not an operator—it indicates that the variable being declared is a pointer.

Pointers can be declared to point to objects of any type.

### Initilializing Pointers

- Pointers should be initialized to nullptr (new in C++11) or to a memory either when they’re declared or in an assignment. 
- A pointer with the value nullptr “points to nothing” and is known as a null pointer. 
- From this point forward, when we refer to a “null pointer” we mean a pointer with the value nullptr.

### Pointer Operators

The unary operators & and * are used to create pointer values and “dereference” pointers, respectively.


The address operator (&) is a unary operator that obtains the memory address of its operand.
Assuming the declarations
```cpp
int y{5}; // declare variable y
int* yPtr{nullptr}; // declare pointer variable yPtr
// the statement 
yPtr = &y; // assign address of y to yPtr
```
assigns the address of the variable y to pointer variable yPtr.


<img src='./images/Screenshot 2024-02-05 133617.png' alt="pointer">

<br>

```cpp
int main (){
    int var1 = 45;

    int *intPtr = &var1; //& symbol denotes address of variable

    cout << "var1 is stored at location" << intPtr << endl; // address of var1
    cout << "var1 is stored at location" << &var1 << endl; // address of var1
    cout << "intPtr is stored at location" << &intPtr << endl; // address of intptr

    cout << "var1's value is " << *intPtr << endl; // dereferencing the pointer
    return 0;
}
```

### Pass-By-Reference with Pointers

There are three ways in C++ to pass arguments to a function
- **pass-by-value**
- **pass-by-reference with reference arguments**
- **pass-by-reference with pointer arguments.**

Here, we explain pass-by-reference with pointer arguments.

Pointers can be used to modify one or more variables in the caller or to pass pointers to large data objects to avoid the overhead of copying the objects.

**You can use pointers and the indirection operator (*) to accomplish pass-by-reference.**

When calling a function with an argument that should be modified, the address of the argument is passed.


```cpp
int square(int x){ // passed by value
    return x *= x;
}

void squareByRef(int &x){ // passed by reference 
    x *= x;
}

void squareByPointer(int *xPtr){ // passed by reference with pointer arg
    *xPter *= *xPter; // dereference
}
```

<br>

### Using const with Pointers

- Many possibilities exist for using (or not using) const with function parameters.

***Principle of least privilege***

- Always give a function enough access to the data in its parameters to accomplish its specified task, but no more.

There are **four** ways to pass a pointer to a function

- **a nonconstant pointer to nonconstant data**
    
    - The highest access is granted by a nonconstant pointer to nonconstant data
    - The data can be modified through the dereferenced pointer
    - The pointer can be modified to point to other data.
    - Such a pointer’s declaration (e.g., int* countPtr) does not include const. 

```cpp
int* countPtr
```
<br>

- **a nonconstant pointer to constant data**

    - A pointer that can be modified to point to any item of the appropriate type
    - The data to which it points cannot be modified through that pointer
    
        - Read from right to left as “countPtr is a pointer to an integer constant” or more precisely, “countPtr is a non-constant pointer to an integer constant.” 
```cpp
 const int* countPtr;
```
<img src='./images/nonconstant_pointer_to_constant_data.png' alt="nonconstant pointer to constant data">

<br>


- **a constant pointer to nonconstant data** 

    - always points to the same memory location
    - the data at that location can be modified through the pointer
    - Pointers that are declared const must be initialized when they’re declared.
    - If the pointer is a function parameter, it’s initialized with a pointer that’s passed to the function.

```cpp
int* const ptr{&x};
```

<img src='./images/constant_pointer_to_nonconstant_data.png' alt='constant pointer to non constant data'>

<br>


- **a constant pointer to constant data** 

    - The minimum access privilege is granted by a constant pointer to constant data.
    - Such a pointer always points to the same memory location
    - The data at that location cannot be modified via the pointer.
    - This is how a built-in array should be passed to a function that only reads from the built-in array, using array subscript notation, and does not modify the built-in array.
        - Read from right to left as “ptr is a constant pointer to an integer constant.” 
```cpp
const int*  const
```

<img src='./images/constant_pointer_to_constant_data.png' alt='Constant Pointer to Constant Data'>

<br>


Each combination provides a different level of access privilege.

<hr>

***Date:** 2/7/24*

## Classes: A deeper look

### Introduction

- Using an *include guard* in a header to prevent header code from being included in the same source code file more than once. 
- Using an ostringstream to create string representations of objects.
- An overview of the compile/link process.
- Accessing object members via the object’s name, a reference to an object and a pointer to an object.
- Access functions that can read or write an object’s data members.
- Utility functions—private member functions that support the operation of the class’s public member functions.
- How default arguments can be used in constructors.
- Destructors that perform “termination housekeeping” on objects before they’re destroyed.
- The *order* in which constructors and destructors are called.
- How returning a reference or pointer to private data *breaks the encapsulation* of a class, allowing client code to directly access an object’s data.
- Default memberwise assignment to assign an object of a class to another object of the same class.
- const objects and const member functions to prevent modifications of objects and enforce the principle of least privilege. 
- **Composition**—a form of reuse in which a class can have objects of other classes as members. 
- **Friendship** to specify that a nonmember function can also access a class’s non-public members—a technique that’s often used in operator overloading for performance reasons. 
- ``this`` pointer, which is an implicit argument in all calls to a class’s non-static member functions, allowing them to access the correct object’s data members and non-static member functions. 

### ``Time`` Class Case Study

We're going to have **3** files:

- Account.h
- Time.h
    
    - Will contain:
    - datamembers
    - member function prototypes (functions without a body) 
- Time.cpp

    - member function implementations
    - source code hidden from the client 


Time.h
```cpp
// Time.h
// Time Class Definition
// Member functions are defined in Time.cpp
#include <string>

// prevent multiple inclusions of header
#ifndef TIME_H
#define TIME_H

//Time class definition
class Time {
    public: 
        void setTime(int, int, int); // set hour, minute and second
        std::string toUniversalString() const;
        std::string toStandardString() const;
    private:
        unsigned int hour{0}; // 0 - 23 (24-hour clock format)
        unsigned int minute{0}; // 0 - 59
        unsigned int second{0}; // 0 - 59
};

#endif
```


Time.cpp
```cpp
// Time.cpp
// Time class member-function definitions
#include <iomanip> // for setw and setfill stream manipulators
#include <stdexcept> // for invalid_argument exception class
#include <sstream> // for ostringstream class
#include <string>
#include "Time.h" // include definition of class Time from Time.h

using namespace std;

void Time::setTime(int h, int m, int s){
    // valudate hour, minute and second
    if ((h >= 0 && h < 24) && (m >= 00 && m < 60) && (s >= 0 && s < 60)){
        hour = h;
        minute = m;
        second = s;
    } else {
        throw invalid_argument(
            "hour, minute, and/or second was out of range");
    }
}

// return Time as a string in universal-time format (HH:MM:SS)
string Time::toUniversalString() const{
    ostringstream output;
    output << setfill('0') << setw(2) << hour << ":" << setw(2) << minute << ":" << setw(2) << second;
    return output.str(); // returns the formatted string
}

// return Time as string in standard-time format (HH:MM:SS AM or PM)
string Time::toStandardString() const{
    ostringstream output; 
    output << ((hour == 0 || hour == 12) ? 12: hour % 12 ) << ":" << setfill('0') << set2(2) << minute << ":" << setw(2) << second << (hour < 12 ? " AM" : " PM">);
    return output.str(); // returns the formatted string
}
```

NOTE: **setfill** is a **sticky function** and will affect the rest of the stream, **setw** is **not** and has to be called before every string


main.cpp
```cpp
// File to test Time class
// NOTE: this file must be compiled with Time.cpp
#include <iostream>
#include <stdexcept> // invalid_argument exception class
#include "Time.h" // definition of class Time

using namespace std;

// displays a Time in 24-hour and 12-hour formats
void displayTime(const string& message, const Time& time){
    cout << message << "\nUniversal time: " << time.toUniveralString() << "\nStandard Time: " << time.toStandardString() << "\n\n";
}

int main(){
    Time t; //instantiate object t of class Time

    displayTime("Initial time:", t); //displays t's intial value

    t.setTime(13,27, 6); // change time
    displayTime("After setTime: ", t); // displays t's new value

    //attempt to set the time with invalid values
    try {
        t.setTime(99,99,99);
    } 
    catch (invalid_argument& e){
        cout << "Exception:" << e.what() << "\n\n";
    }

    //display t's value after attempting to set an invalid time
    displayTime("After attempting to set an invalid time:", t);
}
```

### !!! important note !!!

```
In Microsoft Visual Studio, add to your project all the headers and source-code files that make up a program, then build and run the project

For GNU C++, open a shell and change to the directory containing all the files for a given program, then execute the following command:

g++ -std=c++14 *.cpp -o ExecutableName

*.cpp specifies to compile and link all of the source-code files in the current directory—the preprocessor automatically locates the headers in that directory.

Could also manually compile each file with 

g++ -o output_name file_name.cpp file_name2.cpp

which will output an executable with default name a.out
```

